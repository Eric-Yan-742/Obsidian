[Course Schedule - LeetCode](https://leetcode.com/problems/course-schedule/description/)

## Kahn's Algorithm (BFS based)

[Solution](https://leetcode.com/problems/course-schedule/solutions/58509/c-bfs-dfs/)

I think there might be some incorrect statements about the BFS solution.
First of all, I don't think it should be called BFS solution. I think you basically used Kahnâ€™s algorithm here. However, I did not found BFS is mentioned in that link.

BFS, in my opinion, decide the order of visited nodes. For example, if we have course A and B which both have zero indegree at first, and put them into queue. Let's say we take course A out first, and A have two neighbors C, D. After we reduce C and D's indegree by 1, they both have zero indegree and will be put into queue. In this case, we should visit C and D before B, and that's how BFS works.

While in Khan's algorithm, we visit B before C and D, which to me, it is not breadth-first because BFS should visit one node's neighbors after visit that node.

Second, your solution is slightly different to Khan's algorithm, and I think the way Khan push all zero-indegree nodes into queue at first is more efficient.


```cpp
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        graph g = buildGraph(numCourses, prerequisites);
        vector<int> degrees = computeIndegrees(g);
        list<int> sources;
        for(int i = 0; i < numCourses; i++) {
            if(degrees[i] == 0) sources.push_back(i);
        }
        for (int i = 0; i < numCourses; i++) {
            if(sources.empty()) return false;
            int s = sources.back();
            sources.pop_back();
            for (int v : g[s]) {
                degrees[v]--;
                if(degrees[v] == 0) sources.push_back(v);
            }
        }
        return true;
    }
private:
    typedef vector<vector<int>> graph;
    
    graph buildGraph(int numCourses, graph& prerequisites) {
        graph g(numCourses);
        for (auto p : prerequisites) {
            g[p[1]].push_back(p[0]);
        }
        return g;
    }
    
    vector<int> computeIndegrees(graph& g) {
        vector<int> degrees(g.size(), 0);
        for (auto adj : g) {
            for (int v : adj) {
                degrees[v]++;
            }
        }
        return degrees;
    }
};
```

## DFS

```cpp
class Solution {
public:
    bool canFinish(int numCourses, vector<pair<int, int>>& prerequisites) {
        graph g = buildGraph(numCourses, prerequisites);
        vector<bool> todo(numCourses, false), done(numCourses, false);
        for (int i = 0; i < numCourses; i++) {
            if (!done[i] && !acyclic(g, todo, done, i)) {
                return false;
            }
        }
        return true;
    }
private:
    typedef vector<vector<int>> graph;
    
    graph buildGraph(int numCourses, vector<pair<int, int>>& prerequisites) {
        graph g(numCourses);
        for (auto p : prerequisites) {
            g[p.second].push_back(p.first);
        }
        return g;
    }
    
    bool acyclic(graph& g, vector<bool>& todo, vector<bool>& done, int node) {
        if (todo[node]) {
            return false;
        }
        if (done[node]) {
            return true;
        }
        todo[node] = done[node] = true;
        for (int v : g[node]) {
            if (!acyclic(g, todo, done, v)) {
                return false;
            }
        }
        todo[node] = false;
        return true;
    }
};
```