- [Permutations II - LeetCode](https://leetcode.com/problems/permutations-ii/description/)
- Classic removal. We only remove duplicate at the same level.
- Tree Structure
    - ![[d7f74363deb7310e2fc70cd14441308.jpg]]
    - Refer to [[40. Combination Sum II]]. 
	1. Scenario 1 is still the same. If we don't use the same element, path on the same branch will always be different permutations.
	2. Scenario 2 will visit the same combinations in the same order. That's why we need to remove duplicates in the same level.
	3. We can ignore scenario 3 right now. Although we may visit the same combinations in different orders, they are considered different permutations. Thus, there's no need to sort the array.
    
- Use set
    
    ```C++
    class Solution {
    private:
        vector<int> path;
        vector<vector<int>> res;
        void backtracking(vector<int>& nums, vector<bool>& used) {
            if(path.size() == nums.size()) {
                res.push_back(path);
                return;
            }
            // use a set per level
            unordered_set<int> used_level;
            for(int i = 0; i < nums.size(); i++) {
                if(used[i]) continue;
                if(used_level.find(nums[i]) != used_level.end()) continue;
                used_level.insert(nums[i]);
                used[i] = true;
                path.push_back(nums[i]);
                backtracking(nums, used);
                path.pop_back();
                used[i] = false;
            }
        }
    public:
        vector<vector<int>> permuteUnique(vector<int>& nums) {
            vector<bool> used(nums.size(), false);
            backtracking(nums, used);
            return res;
        }
    };
    ```
    
- Because order does matter for permutation, so we don’t need to sort the array at first
- Use array
    
    ```C++
    class Solution {
    private:
        vector<vector<int>> result;
        vector<int> path;
        void backtracking (vector<int>& nums, vector<bool>& used) {
            // 此时说明找到了一组
            if (path.size() == nums.size()) {
                result.push_back(path);
                return;
            }
            for (int i = 0; i < nums.size(); i++) {
                // used[i - 1] == true，说明同一树枝nums[i - 1]使用过
                // used[i - 1] == false，说明同一树层nums[i - 1]使用过
                // 如果同一树层nums[i - 1]使用过则直接跳过
                if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                    continue;
                }
                if (used[i] == false) {
                    used[i] = true;
                    path.push_back(nums[i]);
                    backtracking(nums, used);
                    path.pop_back();
                    used[i] = false;
                }
            }
        }
    public:
        vector<vector<int>> permuteUnique(vector<int>& nums) {
            result.clear();
            path.clear();
            sort(nums.begin(), nums.end()); // 排序
            vector<bool> used(nums.size(), false);
            backtracking(nums, used);
            return result;
        }
    };
    ```
    
- Coincidentally, we can also only eliminate duplicate in a branch ( `used[i - 1] == true` ) if we sort the array. This is because all our permutations equal to the length of the array, so we only keep the **last one** of the duplicate. If the duplicate is not the last one, it will always encounter its next duplicate somehwere in this branch, and thus that branch is eliminated. But compared to eliminate by level, we do lots more useless searches.
    
    ![[_attachments/Untitled 31.png|Untitled 31.png]]
    
    ![[_attachments/Untitled 1 2.jpeg|Untitled 1 2.jpeg]]
    
- Time: $O(n^n)$﻿
    - `result.push_back(path);` takes $O(n)$﻿
- Space: $O(n)$