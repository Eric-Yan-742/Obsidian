- 什么是TCP：TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。
    
    ![[_attachments/Untitled 85.png|Untitled 85.png]]
    
    - **面向连接**：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
    - **可靠的**：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
    - **字节流**：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。
    - **有序的**：并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。
- TCP和UDP的区别
    1. TCP需要连接，UDP不需要连接
    2. TCP一对一，UDP一对多
    3. TCP可靠传输数据，保证数据不丢失，按序，不重复。UDP是尽最大努力交付，不保证可靠交付数据
    4. TCP有流量控制和拥塞控制，UDP没有
    5. TCP基于字节流，UDP面向报文（每一个报文中的数据就是用户消息的边界）
    6. TCP头部有至少20个字节，开销更大。UDP头部只有8个字节
- TCP/UDP的应用场景
    - TCP面向连接，能保证数据可靠交付因此经常用于**FTP文件传输**和**HTTP/HTTPS**。
    - TCP无连接，简单高效。通常用于包总量较少的通信如**DNS（查询服务器域名对应的 IP 地址，域名解析）、SNMP。音视频等多媒体通信（低延迟），广播通信**。
- TCP四元组
    
    ![[_attachments/Untitled 1 40.png|Untitled 1 40.png]]
    
    一个四元组对应一个TCP连接，也就是说同一个四元组只能有一个连接
    
- Seq和Ack的变化（抓包）
    - 握手挥手：[HCIA——TCP四次挥手及其wireshark抓包_tcp4次分手抓包-CSDN博客](https://blog.csdn.net/weixin_63172698/article/details/130256294)
        - 一发一应答一发（不会连发）
        - seq = previous ack，ack = **seq + 1，**len = 0（不传输数据）
    - 传输：[Wireshare抓包分析TCP协议_wireshark tcp window update-CSDN博客](https://blog.csdn.net/qq_35337506/article/details/136608821)
        - 发送和应答跟标志位没关系。有些ACK包是在传输数据，有些ACK包是在应答数据
        - 传输数据和应答数据是分开的（不会一个数据包又传输数据又接收数据）
        - 发送数据时
            - 只要窗口还允许seq自增，ack不变，len > 0
        - 回应数据时
            - seq不变，ack = 收到包的seq + len，len = 0

## TCP三次握手

- TCP三次握手：TCP通过三次握手建立连接，之后才可以传输数据
    
    ![[_attachments/Untitled 2 23.png|Untitled 2 23.png]]
    
    1. 一开始，客户端和服务端都处于 `CLOSE` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态
    2. 第一次握手：客户端会随机初始化序号（`client_isn`），将此序号置于 TCP 首部的「序号」字段中，同时把 `SYN` 标志位置为 `1`，表示 `SYN` 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 `SYN-SENT` 状态。
        
        ![[_attachments/Untitled 3 15.png|Untitled 3 15.png]]
        
    3. 第二次握手：服务端收到客户端的 `SYN` 报文后，首先服务端也随机初始化自己的序号（`server_isn`），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 `client_isn + 1`, 接着把 `SYN` 和 `ACK` 标志位置为 `1`。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态。
        
        ![[_attachments/Untitled 4 11.png|Untitled 4 11.png]]
        
    4. 第三次握手：客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1` ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 `ESTABLISHED` 状态。
        
        ![[_attachments/Untitled 5 10.png|Untitled 5 10.png]]
        
    5. 服务端收到客户端的应答报文后，也进入 `ESTABLISHED` 状态。
    
    - **第三次握手是可以携带数据的，前两次握手是不可以携带数据的**
- 为什么TCP需要三次握手，而不是两次握手或四次握手？
    1. 避免历史连接（相同四元组，客户端在发完Seq Num = 90后宕机）
        
        ![[_attachments/Untitled 6 10.png|Untitled 6 10.png]]
        
        如果是两次握手，就无法阻止历史连接（假设由于没有第三次握手，服务端不清楚客户端是否收到了自己发送的建立连接的 `ACK` 确认报文，所以每收到一个 `SYN` 就只能先主动建立一个连接）
        
        ![[_attachments/Untitled 7 9.png|Untitled 7 9.png]]
        
    2. 同步双方序列号
        
        - 序列号的作用
            1. 接收方可以去除重复的数据
            2. 接收方可以根据数据包的序列号得知数据的顺序
            3. 可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）
        - 可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 `SYN` 报文的时候，需要服务端回一个 `ACK` 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，**这样一来一回，才能确保双方的初始序列号能被可靠的同步。**
        
        ![[_attachments/Untitled 8 9.png|Untitled 8 9.png]]
        
        - **四次握手**其实也能够可靠的同步双方的初始化序号，但由于第二步和第三步可以优化成一步，所以就成了「三次握手」。
        - 而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。
- 为什么不是四次握手？四次握手也行，但是服务端发送ACK和SYN可以合并成一步
- 第一次握手丢失了会发生什么：在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且**重传的 SYN 报文的序列号都是一样的**。通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，**每次超时的时间是上一次的 2 倍**。当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。
- 第二次握手丢失了会发生什么：因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是**客户端就会触发超时重传机制，重传 SYN 报文**。然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是**服务端这边会触发超时重传机制，重传 SYN-ACK 报文**。因此，当第二次握手丢失了，客户端和服务端都会重传
- 第三次握手丢失了，如果**服务端**那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。注意，**ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文**。

## TCP四次挥手

- TCP四次挥手断开连接
    
    ![[_attachments/Untitled 9 8.png|Untitled 9 8.png]]
    
    ![[_attachments/Untitled 10 7.png|Untitled 10 7.png]]
    
    两个FIN两个ACK，总计四次挥手
    
    双方都可以主动断开连接，但只有主动断开连接的一方才有TIME_WAIT状态
    
- 为什么需要四次挥手？发送FIN表示停止发送数据但还可以接收数据，只有双方都停止发送数据了才关闭连接。服务端在知道客户端停止发送数据后，得把剩下的数据发送完才能关闭连接。
- 第一次挥手丢失：客户端发送FIN进入FIN_WAIT1等待ACK，客户端触发超时重传FIN，达到重传上限后关闭。服务端因为什么也没收到所以一直处于establish状态
    
    ![[_attachments/Untitled 11 7.png|Untitled 11 7.png]]
    
- 第二次挥手丢失：客户端发给服务端FIN并进入FIN_WAIT1状态，服务端进入CLOSE_WAIT状态并回ACK，ACK丢失。客户端超时重发，继续丢失直到上限，客户端关闭，服务端处于CLOSE_WAIT
    
    ![[_attachments/Untitled 12 6.png|Untitled 12 6.png]]
    
- 第三次挥手丢失
    
    ![[_attachments/Untitled 13 5.png|Untitled 13 5.png]]
    
- 第四次挥手
    
    ![[_attachments/Untitled 14 5.png|Untitled 14 5.png]]
    
- 为什么TIME_WAIT等待的时间是2MSL？
    
      
    
- TCP重发机制
    - 超时重传：为每一个设定一个定时器，当超过指定的时间后，没有收到对方的 `ACK` 确认应答报文，就会重发该数据。
        - `RTO` 超时重传时间， `RTT` 数据包往返的时间
    - 快速重传：以接收方的ACK驱动数据重传，如果收到三个相同的ACK报文，说明有数据丢失了，发送方会重传丢失的报文段。在定时器超时之前重传，节省时间。
- TCP滑动窗口/流量控制：用于流量控制，发包的范围必须在窗口大小之内，防止发送方发送过多数据接收方处理不了。并且在接收方能力允许的情况下可以连续发包，增加传输效率。
    
    ![[_attachments/Untitled 15 5.png|Untitled 15 5.png]]
    
    ![[_attachments/Untitled 16 4.png|Untitled 16 4.png]]
    
    - 双方都能收发数据数据，所以双方都有两个窗口
    - 滑动窗口的大小是接收方控制的，通过Window字段将大小告诉发送方，控制发送方的发送速率
    - 只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫**累计确认**或者**累计应答**。
    - 关于连续发送包如何重传：[42、可靠传输——连续ARQ-CSDN博客](https://blog.csdn.net/m0_47169474/article/details/132294526)
- TCP队头阻塞
    - 接收方如果碰到了不连续的信息（先收到了32，33但没收到31），不会把后面的信息交给应用层，也不会滑动窗口，直到收到了丢掉的包，这样确保了数据的有序性。但延缓了接收方将数据递交给应用层
- Nagle算法
    
    - 糊涂窗口综合症：窗口很小，可能只有几个字节，但发送方还是不遗余力地发送那几个字节，一个TCP头都有四十字节，这样的小封包会增加网络负载。
    - 接收方：当「窗口大小」小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 `0`，防止发送小窗口
    - 发送方：使用Nagle算法，避免发送小封包
        - 条件1：等到窗口大小 >= `MSS` 并且 数据大小 >= `MSS`
        - 条件2：接到了之前所有数据的回应
        - 不满足任何一个条件就将数据囤积在缓存中。
    
    ```C
    if 有数据要发送 {
        if 可用窗口大小 >= MSS and 可发送的数据 >= MSS {
        	立刻发送MSS大小的数据
        } else {
            if 有未确认的数据 {
                将数据放入缓存等待接收ACK
            } else {
                立刻发送数据
            }
        }
    }
    ```
    
- 也就是说只有窗口大+要传输的数据多（多于一个包可以传输的量）才会不等ACK连续发包
    
    ![[_attachments/Untitled 17 4.png|Untitled 17 4.png]]
    
    关闭Nagle算法：只要缓冲内有待发送数据并且在窗口范围内就发，不管有几个字节
    
- TCP拥塞控制：避免发送方的数据使整个网络过于拥挤,**拥塞窗口** `**cwnd**` 是发送方维护的一个的状态变量，它会根据**网络的拥塞程度动态变化的**。
    - 慢启动：cwnd < ssthresh, 一开始初始化 `cwnd = 1` 收到一个ACK， `cwnd + 1 = 2` 收到2个ACK, `cwnd + 2 = 4` 成指数增长
    - 避免拥塞算法：cwnd ≥ ssthresh 每当收到一个 ACK 时，cwnd 增加 1/cwnd，窗口变成线性增长
    - 拥塞发生算法：
        - 发生超时重传，ssthresh设为cwnd/2 ，cwnd重置为初始值，重新慢开始（更强烈）
        - 发生快速重传：将ssthresh设为cwnd/2，重传丢掉的包，之后将cwnd设为ssthresh（只减半，更温和）