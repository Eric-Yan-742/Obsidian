- HTTP是什么：HTTP 是超文本传输协议，也就是**H**yperText **T**ransfer **P**rotocol。规定了浏览器和服务器之间数据传输的规则。
    
    ![[_attachments/Untitled 84.png|Untitled 84.png]]
    
- HTTP基于TCP协议，安全
- HTTP基于请求-响应模型的：一次请求对应一次响应。（无请求就无响应）
- HTTP是无状态的协议：多次请求之间不会数据共享
    - 优点：速度快
    - 缺点：
- http请求报文：本质就是字符串
    
    ![[_attachments/Untitled 1 39.png|Untitled 1 39.png]]
    
    请求URL就是请求的资源路径。报文/请求头是 key: value方式储存的。
    
    - HTTP常见请求字段
        
        - _Host_ 字段：客户端发送请求时，用来指定服务器的域名。
            
            ![[_attachments/Untitled 2 22.png|Untitled 2 22.png]]
            
        
        - 其他
            
            ![[_attachments/Untitled 3 14.png|Untitled 3 14.png]]
            
            ![[_attachments/Untitled 4 10.png|Untitled 4 10.png]]
            
            Use-Agent是浏览器版本，服务器收到请求后可以分类处理解决浏览器的兼容问题，保证任何浏览器所访问到的内容都是一样的。
            
- GET和POST区别
    - GET：用于从服务器获取资源，通常用于请求数据，不会对服务器上的资源进行修改。
    - POST：用于向服务器提交数据，通常用于发送数据给服务器，可能会对服务器上的资源进行修改。
    - GET 请求的参数位置一般是写在 URL 中。POST 请求携带数据的位置一般是写在报文 body（请求正文）中
    - 浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。浏览器不会对 body 大小做限制。所以POST可以比GET传递更多数据
    - URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符。body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可。
    - 在 HTTP 协议里，所谓的「**安全**」是指请求方法不会「破坏」服务器上的资源。
    - 所谓的「**幂等**」，意思是多次执行相同的操作，结果都是「相同」的。
    - **GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，**可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签**。
    - **POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。所以，**浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签**。
- HTTP响应报文
    
    ![[_attachments/Untitled 5 9.png|Untitled 5 9.png]]
    
    - 响应状态码：状态码代表响应是否成功
        
        ![[_attachments/Untitled 6 9.png|Untitled 6 9.png]]
        
        重定向：所在的资源已经迁移到了另一台服务器/另一个位置。服务器返回3xx，浏览器自动访问新的位置。
        
    - 常见状态码：200 OK, 404 Not Found, 500 Internal Server Error
    - 响应头
        
        ![[_attachments/Untitled 7 8.png|Untitled 7 8.png]]
        
- 什么是长连接短连接
    
    - 短链接 (HTTP 1.0): 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。
    - 长连接 (HTTP 1.1)：持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。
    
    ![[_attachments/Untitled 8 8.png|Untitled 8 8.png]]
    

# HTTP/HTTPS

- HTTPS和HTTP的区别？
    - HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
    - HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
    - 两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。
    - HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。
- HTTP解决了HTTP的哪些问题
    - HTTP的缺点
        - 明文传输，导致有窃听风险（不加密）
        - 篡改风险（无法验证报文完整性）例如植入广告
        - 冒充风险（不验证通信方身份）例如访问假淘宝
    - HTTPS引入了SSL/TLS协议来解决这些问题
        
        ![[_attachments/Untitled 9 7.png|Untitled 9 7.png]]
        
- 混合加密：解决了窃听的风险
- 摘要算法不能防止中间人替换【内容+哈希值】：举个例子，我发了内容1对应哈希值A，中途有人把内容1篡改成了内容2。内容2对应哈希值B。对比哈希值A和B本该能发现篡改的。但那人把哈希值也给换成B了。接收者就误以为内容没被篡改过。
- 对称，非对称。为什么只有客户端发的需要加密，服务器发的不需要加密吗。
- https加密
- https检验证书合法性的过程

# HTTP 1.1/2/3 演变

![[_attachments/Untitled 10 6.png|Untitled 10 6.png]]

## HTTP/1.1 相较于 HTTP/1.0

- 改进
    - 使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。
    - 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。（实际上 HTTP/1.1 管道化技术不是默认开启，而且浏览器基本都没有支持）
- 缺陷
    - 请求 / 响应头部（Header）未经压缩就发送，头部信息越多延迟越大。只能压缩 `Body` 的部分；
    - 每次互相发送相同的冗长头部造成的浪费较多
    - **队头阻塞**：同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了**队头阻塞**的问题。
        
        ![[_attachments/Untitled 11 6.png|Untitled 11 6.png]]
        
        HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞。
        
    - 请求只能从客户端开始，服务器只能被动响应。

## HTTP/2.0 相较于 HTTP/1.1

- 改进
    - 头部压缩：使用HPACK算法，在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号（二进制），以后就不发送同样字段了，只发送索引号，减少数据量
    - 二进制编码：之前使用ASCII对头部进行编码，现在改为二进制编码。将请求和响应拆成二进制帧。帧的类型和内容（HPACK索引）都是二进制编码，这样计算机能更快的解析出报文的内容。
    - 并发传输：多个 Stream 跑在一条 TCP 连接，同一个 HTTP 请求与响应是跑在同一个 Stream 中。多个stream的帧是可以乱序发送的，因此可以并发多个请求与响应。
        - HTTP 消息可以由多个 Frame 构成， 一个 Frame 可以由多个 TCP 报文构成。
    - 服务器主动推送资源：无需客户端每次都请求，服务端可以主动推送资源，减少了消息传递的次数
        - 如何实现的：服务器推送资源时，会先发送 PUSH_PROMISE 帧，告诉客户端接下来在哪个 Stream 发送资源，然后用偶数号 Stream 发送资源给客户端。
- 缺陷
    - 依旧存在队头阻塞的问题，问题在TCP这一层。TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用。如果某一个流的TCP包丢失了，后面到达的流都不能被处理，直到这个包被重传。
        
        ![[_attachments/Untitled 12 5.png|Untitled 12 5.png]]
        
        一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。
        

## HTTP/3 相较于 HTTP/2

- 把下层的TCP换成了UDP，基于UDP的QUIC协议可以实现类似TCP的可靠性传输。
- UDP 发送是不管顺序，也不管丢包的
- QUIC基于UDP怎么实现可靠的
    - 重传机制：待发送端获知数据包Packet N 丢失后，会将需要重传的数据包放到待发送队列，重新编号比如数据包Packet N+M后重新发送给接收端。
    - 有序性：虽然包是乱序到达的（重传的包序号不一样），但是每一个QUIC Frame中都带Stream ID和Offset，接收端通过 Stream ID + Offset 字段将乱序的包重新组装起来。
- QUIC流量控制：[HTTP协议以及基于UDP实现可靠的协议QUIC-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1932051) 接收端即使有丢包也会滑动窗口，可以接收后面的包并回复应答。

1. 无队头阻塞：QUIC给每个Stream都分配了一个滑动窗口，当某个流发生丢包时，也只会影响这个流，其他流不会受到影响，因此不存在队头阻塞问题。
    
    ![[_attachments/Untitled 13 4.png|Untitled 13 4.png]]
    
2. 更快建立连接：QUIC 内部包含了 TLS，仅需三次握手就可以同时建立连接与密钥协商
    
    ![[_attachments/Untitled 14 4.png|Untitled 14 4.png]]
    
3. 连接迁移：当设备的**IP 地址变化了（四元组变化了），就必须要断开连接，然后重新建立连接**。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过**连接 ID** 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了**连接迁移**的功能。

  

  

- http请求的处理流程
    
    1. 客户端向服务器发送HTTP请求。
    2. 服务器接收到请求后，根据请求行中的方法和URL，找到对应的处理程序。
    3. 服务器处理请求，可能包括读取数据库、执行业务逻辑等操作。
    4. 服务器生成HTTP响应，包括响应头部和响应体。
    5. 服务器将响应发送给客户端。
    6. 客户端接收到响应后，根据响应头部和响应体进行处理，如渲染页面、显示数据等。
    
    ![[_attachments/Untitled 15 4.png|Untitled 15 4.png]]